***************
REIL Translator
***************

Hexagon to REIL translator.

Intended primarily to be used with `BARF`_, which implements a modified version of the original `REIL specification`_. 

.. _REIL specification: https://www.zynamics.com/binnavi/manual/html/reil_language.htm

.. _BARF: https://github.com/programa-stic/barf-project

The **Hexagon instructions behavior** (defined in the Reference Manual) is used to perform the translation. This behavior is actually a pseudo-code that implements Hexagon instructions in more simple (low level) and atomic ones, that are closer to the REIL language. This pseudo-code is not formally defined (AFAIK), there is no specification for it in the Reference Manual, but it is very regular, so an unofficial specification can be derived from it, as the behavior instructions are included to the translator.

The translation is perform on the behavior pseudo-code instructions themselves, so the translator relies in the correct definition of the Hexagon instruction behaviors.

The behavior code is parsed using `PLY`_, the translation is performed during the parsing process (as opposed to constructing an AST and processing that later).

.. _PLY: https://github.com/dabeaz/ply


Parser
======

This section explains the inner workings of the parser generated by PLY, using the `PLY documentation`_ as a guide.

	The semantic behavior of a language is often specified using a technique known as syntax directed translation. In syntax directed translation, attributes are attached to each symbol in a given grammar rule along with an action. Whenever a particular grammar rule is recognized, the action describes what to do.

The *action* the parser takes every time a rule is recognized is the generation of the equivalent REIL code, the parser functions are "overloaded" so it does most of the translation process.

	A good way to think about syntax directed translation is to view each symbol in the grammar as a kind of object. Associated with each symbol is a value representing its "state" (for example, the val attribute above). Semantic actions are then expressed as a collection of functions or methods that operate on the symbols and associated values.

Each expression recognized by the parser generates an object whose "state" is the name of the register that contains its value. This register can either be an Hexagon register or a REIL temporal register created for this purpose.

	The output of yacc.py is often an Abstract Syntax Tree (AST). However, this is entirely up to the user. If desired, yacc.py can also be used to implement simple one-pass compilers.

The parser generated by Yacc in this translator is a **one pass compiler**, no AST is used, each time a grammar rule is recognized its corresponding action generates the equivalent REIL code. This method works good enough for most cases, except for more elaborated logic like IF conditionals, where the parser would first generate the REIL code of the statements inside the IF block before generating the REIL branch of the IF that controls its execution (because the parser recognizes the inner grammar rules inside the IF block before noticing that it belongs to an IF clause). The same happens for IF/ELSE conditionals, or FOR loops.

To accommodate those other cases, instruction containers are used, to represent a list of sequential instructions (similar to basic blocks), encapsulated in ``HexagonTranslationBuilder`` objects, that allows to combine them in the right order (e.g., putting the IF branch before the statements inside the IF block). This class inherits from BARF's ``TranslationBuilder`` which contains the list of generated REIL instructions (``self._instructions``), and in its derived class the ``self._value`` attribute is added to represent the state of the REIL instructions: if the list of REIL instructions represent an expression it will have the name of the register containing its value; if the instructions represent a statement ``self._value`` will be ``None`` (as a statement already resolved its value, e.g., performing an assignment).


.. _PLY documentation: http://www.dabeaz.com/ply/ply.html#ply_nn22


TODOs
=====

* Define a small subset of Hexagon instructions to translate for the initial version of the translator (whose objective is not the translation itself but to define the underlying mechanism of the translation process). These subset should be the easiest of the most used instructions (as observed in the binary examples like ``factorial.elf``).

* Define a basic API to use the translator. This API should be as close as BARF's as possible (even though their underlying mechanisms of translation differ), to facilitate its future integration.

* Explain difference between BARF translation and this one.

* Define an informal specification for the behavior pseudo-code instructions (maybe a summary, compilation, or classification are more adequate terms). At the very least, every pseudo-code instruction added to the translator should be included in a list.

* Add an example in this documentation of a simple translation of an Hexagon instruction with 3 or 4 behavior pseudo-code instructions.

* Define vocabulary. There is an Hexagon instruction (e.g., ``Rd = add(Rs, #s16)``) and its corresponding behavior pseudo-code instructions that represent it (e.g., ``Rd = Rs + #s``). Only when the context is clear enough the simple "instruction" term (without additional qualifications) should be used.

* Introduce PLY translation source code progressively, clearly documenting and explaining what it does, do not add it all at once.

* Review PLY documentation, the current implementation of the translator generates the REIL code in a single pass (during the parsing process), review the name of that parsing mode. Is this mode enough to cover all of the logic of the behavior pseudo-code like ``if/else`` branches and loops?

* Add unit testing (similar to BARF).

* Currently this translator is a sub-package (``reil``) of the disassembler python package (``hexagondisasm``). Should this be in a separate package?

* Review the behavior instructions of the repository database (``hexagondisasm/data/instruction_definitions.pkl``) to check how many Hexagon behaviors have been correctly parsed from the Manual, and if that's enough for the first version of the translator.

* Add PLY to the dependencies in ``setup.py``.
